import torch
import torch.nn as nn
from torch.utils.data import Dataset, DataLoader
from time import sleep, perf_counter, localtime, strftime
import os
from flask import Flask, request, jsonify
from flask_cors import CORS

def sano(sanottava, viive=0):
    print(sanottava)
    sleep(viive)

def tallenna_tarina(tarina, tiedostonimi="tarina.txt"):
    if not os.path.exists(tiedostonimi):
        with open(tiedostonimi, "w", encoding="utf-8"):
            pass
    with open(tiedostonimi, "a", encoding="utf-8") as f:
        f.write(tarina + "\n\n")
    sano(f"Tarina tallennettu tiedostoon {tiedostonimi}!")

here = os.path.dirname(__file__)
tarinat_path = os.path.join(here, "tarinat.py")
tarinat = open(tarinat_path, "r", encoding="utf-8").read()

text = tarinat

chars = sorted(list(set(text)))
char2idx = {ch: i for i, ch in enumerate(chars)}
idx2char = {i: ch for i, ch in enumerate(chars)}

seq_length = 150

class TarinaDataset(Dataset):
    def __init__(self, text, seq_lenght):
        self.text_as_int = [char2idx[ch] for ch in text]
        self.seq_lenght = seq_lenght

    def __len__(self):
        return len(self.text_as_int) - self.seq_lenght

    def __getitem__(self, idx):
        x = self.text_as_int[idx:idx+self.seq_lenght]
        y = self.text_as_int[idx+1:idx+self.seq_lenght+1]
        return torch.tensor(x), torch.tensor(y)
    
dataset = TarinaDataset(text, seq_length)
dataloader = DataLoader(dataset, batch_size=32, shuffle=True)    

class TarinaRNN(nn.Module):
    def __init__(self, vocab_size, hidden_size=128, num_layers=2):
        super().__init__()
        self.embedding = nn.Embedding(vocab_size, hidden_size)
        self.lstm = nn.LSTM(hidden_size, hidden_size, num_layers, batch_first=True, dropout=0.4)
        self.fc = nn.Linear(hidden_size, vocab_size)

    def forward(self, x, hidden=None):
        x = self.embedding(x)
        output, hidden = self.lstm(x, hidden)
        output = self.fc(output)
        return output, hidden
    
if os.path.exists("/home/toivo/backup/Python/tarinaAI.pth"):
    data = torch.load("/home/toivo/backup/Python/tarinaAI.pth")

    chars = data["chars"]
    char2idx = data["char2idx"]
    idx2char = data["idx2char"]

    model = TarinaRNN(len(chars), hidden_size=280, num_layers=3)
    model.load_state_dict(data["model_state"])

    optimizer = torch.optim.Adam(model.parameters(), lr=0.003)
    criterion = nn.CrossEntropyLoss()
    sano("Malli on jo opetettu!")

else:
    chars = sorted(list(set(text)))
    char2idx = {ch: i for i, ch in enumerate(chars)}
    idx2char = {i: ch for i, ch in enumerate(chars)}

    model = TarinaRNN(len(chars), hidden_size=280, num_layers=3)
    optimizer = torch.optim.Adam(model.parameters(), lr=0.003)
    criterion = nn.CrossEntropyLoss()
    sano("Mallin opetus aloitetaan...")  

    nyt = localtime()
    sano(f"Opetus aloitettu aikaan {strftime('%H:%M:%S', nyt)}")

    epochit = 45

    alku = perf_counter()

    for epoch in range(epochit):
        sano(f"epoch {epoch + 1} aloitettu!")

        for x, y in dataloader:
            optimizer.zero_grad()
            output, _ = model(x)
            loss = criterion(output.view(-1, len(chars)), y.view(-1))
            loss.backward()
            torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=1.0)
            optimizer.step()

        torch.save({
            "model_state": model.state_dict(),
            "chars": chars,
            "char2idx": char2idx,
            "idx2char": idx2char
        }, "/home/toivo/backup/Python/tarinaAI.pth")

        kulunut = perf_counter() - alku
        keskiaika = kulunut / (epoch + 1)
        kokonaisennuste = keskiaika * epochit
        jaljella = kokonaisennuste - kulunut

        tunnit = int(jaljella // 3600)
        minuutit = int((jaljella % 3600) // 60)
        sek = int(jaljella % 60)

        sano(f"Arvio jäljellä: {tunnit} h {minuutit} min {sek} s")
    

    loppu = perf_counter()
    nyt = localtime()
    sano(f"Opetus lopetettu aikaan {strftime('%H:%M:%S', nyt)}")

    sekunnit = int(loppu - alku)
    minuutit = 0
    tunnit = 0

    while sekunnit >= 60:
        minuutit += 1
        sekunnit -= 60
    while minuutit >= 60:
        tunnit += 1
        minuutit -= 60    

    sano(f"Opetuksessa kesti {tunnit} tuntia {minuutit} minuuttia ja {sekunnit} sekuntia!")        

def generoi_tarina(start_text="Kettu", lenght=200):
    model.eval()
    chars_out = list(start_text)
    input_seq = torch.tensor([char2idx[ch] for ch in start_text]).unsqueeze(0)
    hidden = None

    for _ in range(lenght):
        output, hidden = model(input_seq, hidden)
        probs = torch.softmax(output[0, -1] / 1.0, dim=0).detach()
        next_char_idx = torch.multinomial(probs, 1).item()
        next_char = idx2char[next_char_idx]
        chars_out.append(next_char)
        input_seq = torch.tensor([[next_char_idx]])

    return "".join(chars_out)

app = Flask(__name__)
CORS(app)

@app.route("/tarina", methods=["POST"])
def tarina():
    data = request.json
    alkusana = data.get("alkusana", "Kettu")
    pituus = int(data.get("pituus", 200))
    
    tarina = generoi_tarina(start_text=alkusana, lenght=pituus)
    return jsonify({"tarina": tarina})

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
